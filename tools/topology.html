<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mode Identity Theory | The Postulate</title>
  <meta name="description" content="Interactive visualization of the topological postulate: S¹ = ∂(Möbius) ↪ S³, ∂S³ = ∅">
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;0,600;1,400&family=IBM+Plex+Mono:wght@300;400;500&display=swap" rel="stylesheet">
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --bg: #050810; --text: #c8dce8;
      --dim: rgba(180,200,220,0.5); --dimmer: rgba(180,200,220,0.3);
      --accent: #6ec1e4; --edge: #e85040; --surface: #88c8e8;
      --serif: 'Cormorant Garamond', Georgia, serif;
      --mono: 'IBM Plex Mono', monospace;
    }
    html, body { width: 100%; height: 100%; overflow: hidden; background: var(--bg); color: var(--text); font-family: var(--mono); }
    canvas { display: block; width: 100%; height: 100%; cursor: grab; }
    canvas:active { cursor: grabbing; }

    /* ── OVERLAY UI ── */
    .overlay { position: fixed; pointer-events: none; z-index: 10; }
    .overlay > * { pointer-events: auto; }

    /* Title */
    .title-bar {
      position: fixed; top: 0; left: 0; right: 0; z-index: 20;
      padding: 24px 28px 16px; text-align: center;
      background: linear-gradient(to bottom, rgba(5,8,16,0.9) 0%, rgba(5,8,16,0.4) 70%, transparent);
      pointer-events: none;
    }
    .title-bar h1 {
      font-family: var(--serif); font-size: 36px; font-weight: 300;
      letter-spacing: 5px; color: rgba(230,240,248,0.9);
    }
    .title-bar .eq {
      font-family: var(--serif); font-size: 19px; font-weight: 400;
      color: var(--dim); letter-spacing: 1px; margin-top: 6px;
    }

    /* Layer toggles */
    .controls {
      position: fixed; left: 24px; top: 50%; transform: translateY(-50%); z-index: 20;
      display: flex; flex-direction: column; gap: 6px;
    }
    .ctrl-btn {
      display: flex; align-items: center; gap: 10px;
      background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.08);
      border-radius: 6px; padding: 10px 14px; cursor: pointer;
      font-family: var(--mono); font-size: 13px; color: var(--dim);
      transition: all 0.3s; letter-spacing: 0.3px; min-width: 160px;
      -webkit-user-select: none; user-select: none;
    }
    .ctrl-btn:hover { background: rgba(255,255,255,0.07); color: var(--text); }
    .ctrl-btn.active { border-color: rgba(255,255,255,0.15); color: var(--text); }
    .ctrl-btn .indicator {
      width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0;
      transition: box-shadow 0.3s, opacity 0.3s;
    }
    .ctrl-btn.active .indicator { box-shadow: 0 0 10px currentColor; }
    .ctrl-btn:not(.active) .indicator { opacity: 0.25; }
    .ind-edge { background: var(--edge); color: var(--edge); }
    .ind-surface { background: #60c8a0; color: #60c8a0; }
    .ind-space { background: var(--accent); color: var(--accent); }
    .ind-wave { background: #f0c040; color: #f0c040; }
    .ind-rotate { background: #b0b8c4; color: #b0b8c4; }

    /* Annotation panel */
    .annotation {
      position: fixed; right: 24px; top: 50%; transform: translateY(-50%); z-index: 20;
      max-width: 220px; padding: 18px 20px;
      background: rgba(5,8,16,0.85); border: 1px solid rgba(255,255,255,0.06);
      border-radius: 8px; backdrop-filter: blur(12px);
      transition: opacity 0.4s;
    }
    .annotation .a-label {
      font-size: 11px; font-weight: 600; letter-spacing: 2px;
      text-transform: uppercase; margin-bottom: 6px; opacity: 0.5;
    }
    .annotation .a-name {
      font-family: var(--serif); font-size: 26px; font-weight: 400;
      margin-bottom: 8px; letter-spacing: 0.5px;
    }
    .annotation .a-body {
      font-size: 14px; color: var(--dim); line-height: 1.65;
    }
    .annotation .a-math {
      font-family: var(--serif); font-size: 19px; color: var(--accent);
      margin: 8px 0; letter-spacing: 0.5px;
    }

    /* Bottom bar */
    .bottom-bar {
      position: fixed; bottom: 0; left: 0; right: 0; z-index: 20;
      padding: 16px 28px 20px; text-align: center;
      background: linear-gradient(to top, rgba(5,8,16,0.9) 0%, rgba(5,8,16,0.4) 70%, transparent);
      pointer-events: none;
    }
    .bottom-bar .hint {
      font-size: 12px; color: rgba(180,200,220,0.3); letter-spacing: 1px;
    }
    .bottom-bar .inscription {
      font-family: var(--serif); font-size: 18px; font-style: italic;
      color: rgba(180,200,220,0.25); letter-spacing: 0.5px; margin-top: 4px;
    }

    @media (max-width: 700px) {
      .title-bar h1 { font-size: 26px; letter-spacing: 3px; }
      .title-bar .eq { font-size: 15px; }
      .controls { left: 12px; }
      .ctrl-btn { min-width: 44px; padding: 10px; }
      .ctrl-btn span { display: none; }
      .annotation { right: 12px; max-width: 180px; padding: 14px; }
      .annotation .a-name { font-size: 22px; }
    }
  </style>
</head>
<body>

<div class="title-bar">
  <h1>THE POSTULATE</h1>
  <div class="eq">S<sup>1</sup> = ∂(Mobius) ↪ S<sup>3</sup>, &nbsp; ∂S<sup>3</sup> = ∅</div>
</div>

<div class="controls">
  <button class="ctrl-btn active" data-layer="space" id="btnSpace">
    <div class="indicator ind-space"></div>
    <span>S<sup>3</sup> Space</span>
  </button>
  <button class="ctrl-btn active" data-layer="surface" id="btnSurface">
    <div class="indicator ind-surface"></div>
    <span>Mobius Surface</span>
  </button>
  <button class="ctrl-btn active" data-layer="edge" id="btnEdge">
    <div class="indicator ind-edge"></div>
    <span>S<sup>1</sup> Edge</span>
  </button>
  <button class="ctrl-btn" data-layer="wave" id="btnWave">
    <div class="indicator ind-wave"></div>
    <span>Wave &Psi;</span>
  </button>
  <div style="height:6px"></div>
  <button class="ctrl-btn active" id="btnRotate">
    <div class="indicator ind-rotate"></div>
    <span>Rotate Model</span>
  </button>
</div>

<div class="annotation" id="annotPanel">
  <div class="a-label" id="aLabel">Topology</div>
  <div class="a-name" id="aName">Three Nested Manifolds</div>
  <div class="a-body" id="aBody">
    The temporal edge S<sup>1</sup> bounds the Mobius surface. The surface embeds in hypersphere space S<sup>3</sup>. The space has no boundary.
  </div>
  <div class="a-math" id="aMath"></div>
</div>

<div class="bottom-bar">
  <div class="hint">drag to orbit · scroll to zoom · click layers to toggle</div>
  <div class="inscription">The identity is the wave &Psi;</div>
</div>

<canvas id="c"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
(function() {

// ── Scene setup ──
var W = window.innerWidth, H = window.innerHeight;
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera(45, W/H, 0.1, 100);
camera.position.set(0, 1.2, 5);
camera.lookAt(0, 0, 0);

var renderer = new THREE.WebGLRenderer({
  canvas: document.getElementById('c'),
  antialias: true, alpha: true
});
renderer.setSize(W, H);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setClearColor(0x050810, 1);

// ── Lighting ──
var amb = new THREE.AmbientLight(0x405060, 0.6);
scene.add(amb);
var dir1 = new THREE.DirectionalLight(0x8ec8f0, 0.8);
dir1.position.set(3, 4, 5);
scene.add(dir1);
var dir2 = new THREE.DirectionalLight(0xf08060, 0.3);
dir2.position.set(-3, -2, -3);
scene.add(dir2);
var pt = new THREE.PointLight(0x6ec1e4, 0.5, 10);
pt.position.set(0, 0, 0);
scene.add(pt);

// ── Stars background ──
var starGeo = new THREE.BufferGeometry();
var starPos = [];
for (var i = 0; i < 2000; i++) {
  var r = 20 + Math.random() * 30;
  var th = Math.random() * Math.PI * 2;
  var ph = Math.acos(2 * Math.random() - 1);
  starPos.push(r * Math.sin(ph) * Math.cos(th), r * Math.sin(ph) * Math.sin(th), r * Math.cos(ph));
}
starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
var starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.08, transparent: true, opacity: 0.6 });
scene.add(new THREE.Points(starGeo, starMat));

// ═══════════════════════════════════════════
//  S³ SPHERE (translucent wireframe)
// ═══════════════════════════════════════════
var sphereR = 1.85;
var sphereGeo = new THREE.SphereGeometry(sphereR, 48, 32);

// Transparent shell
var sphereShell = new THREE.Mesh(sphereGeo, new THREE.MeshPhysicalMaterial({
  color: 0x4488cc, transparent: true, opacity: 0.06,
  roughness: 0.3, metalness: 0.1, side: THREE.DoubleSide,
  depthWrite: false
}));
scene.add(sphereShell);

// Wireframe grid (like lat/long lines)
var wireGeo = new THREE.SphereGeometry(sphereR * 1.001, 24, 16);
var wireMat = new THREE.MeshBasicMaterial({
  color: 0x6ec1e4, wireframe: true, transparent: true, opacity: 0.06,
  depthWrite: false
});
var sphereWire = new THREE.Mesh(wireGeo, wireMat);
scene.add(sphereWire);

// Subtle rim glow using a slightly larger sphere
var glowGeo = new THREE.SphereGeometry(sphereR * 1.02, 32, 24);
var glowMat = new THREE.MeshBasicMaterial({
  color: 0x4488cc, transparent: true, opacity: 0.03,
  side: THREE.BackSide, depthWrite: false
});
var sphereGlow = new THREE.Mesh(glowGeo, glowMat);
scene.add(sphereGlow);

var spaceGroup = [sphereShell, sphereWire, sphereGlow];

// ═══════════════════════════════════════════
//  MOBIUS STRIP (parametric, vertex-colored)
// ═══════════════════════════════════════════
var MR = 1.0;   // major radius
var MW = 0.45;  // half-width
var NU = 200;   // u segments
var NV = 30;    // v segments

function mobiusPos(u, v) {
  var x = (MR + v * Math.cos(u / 2)) * Math.cos(u);
  var y = (MR + v * Math.cos(u / 2)) * Math.sin(u);
  var z = v * Math.sin(u / 2);
  return [x, y, z];
}

var mGeo = new THREE.BufferGeometry();
var mVerts = [], mColors = [], mIndices = [], mNorms = [];

for (var i = 0; i <= NU; i++) {
  var u = (i / NU) * Math.PI * 2;
  for (var j = 0; j <= NV; j++) {
    var v = -MW + (j / NV) * 2 * MW;
    var p = mobiusPos(u, v);
    mVerts.push(p[0], p[1], p[2]);

    // Color: HSL cycling hue with u, saturation varies with v
    var hue = (i / NU) * 360;
    var sat = 0.5 + 0.3 * Math.abs(v / MW);
    var light = 0.45 + 0.15 * (v / MW);
    var c = new THREE.Color();
    c.setHSL(hue / 360, sat, light);
    mColors.push(c.r, c.g, c.b);

    // Normal (approximate via cross product of partial derivatives)
    var du = 0.001, dv = 0.001;
    var pu = mobiusPos(u + du, v), pv = mobiusPos(u, v + dv);
    var tu = [pu[0]-p[0], pu[1]-p[1], pu[2]-p[2]];
    var tv = [pv[0]-p[0], pv[1]-p[1], pv[2]-p[2]];
    var nx = tu[1]*tv[2] - tu[2]*tv[1];
    var ny = tu[2]*tv[0] - tu[0]*tv[2];
    var nz = tu[0]*tv[1] - tu[1]*tv[0];
    var nl = Math.sqrt(nx*nx + ny*ny + nz*nz) || 1;
    mNorms.push(nx/nl, ny/nl, nz/nl);
  }
}

for (var i = 0; i < NU; i++) {
  for (var j = 0; j < NV; j++) {
    var a = i * (NV + 1) + j;
    var b = a + NV + 1;
    mIndices.push(a, b, a + 1);
    mIndices.push(b, b + 1, a + 1);
  }
}

mGeo.setAttribute('position', new THREE.Float32BufferAttribute(mVerts, 3));
mGeo.setAttribute('color', new THREE.Float32BufferAttribute(mColors, 3));
mGeo.setAttribute('normal', new THREE.Float32BufferAttribute(mNorms, 3));
mGeo.setIndex(mIndices);

var mobiusMat = new THREE.MeshPhongMaterial({
  vertexColors: true, side: THREE.DoubleSide,
  transparent: true, opacity: 0.85,
  shininess: 40, specular: 0x334455
});
var mobiusMesh = new THREE.Mesh(mGeo, mobiusMat);
scene.add(mobiusMesh);

// Mesh wireframe overlay (faint triangulation like the TopNoTag image)
var mobiusWire = new THREE.Mesh(mGeo.clone(), new THREE.MeshBasicMaterial({
  color: 0x000000, wireframe: true, transparent: true, opacity: 0.08
}));
scene.add(mobiusWire);

var surfaceGroup = [mobiusMesh, mobiusWire];

// ═══════════════════════════════════════════
//  S¹ BOUNDARY EDGE (red/coral glowing line)
// ═══════════════════════════════════════════
// The boundary of the Mobius strip is a single closed curve.
// Trace v = +MW as u goes 0 to 4π (traverses the strip twice to close).
var edgePts = [];
var EDGE_N = 600;
for (var i = 0; i <= EDGE_N; i++) {
  var u = (i / EDGE_N) * Math.PI * 4;
  // The boundary alternates between v=+MW and v=-MW across the half-twist
  var vSign = (i <= EDGE_N / 2) ? MW : -MW;
  // Actually, for a continuous boundary: parametrize as v = MW, u from 0 to 4π
  var p = mobiusPos(u, MW);
  edgePts.push(new THREE.Vector3(p[0], p[1], p[2]));
}

// Core edge line
var edgeCurve = new THREE.BufferGeometry().setFromPoints(edgePts);
var edgeCore = new THREE.Line(edgeCurve, new THREE.LineBasicMaterial({
  color: 0xe85040, linewidth: 2, transparent: true, opacity: 0.95
}));
scene.add(edgeCore);

// Glow edge (wider, dimmer)
var edgeGlow = new THREE.Line(edgeCurve.clone(), new THREE.LineBasicMaterial({
  color: 0xff6050, linewidth: 1, transparent: true, opacity: 0.35
}));
scene.add(edgeGlow);

// Edge particle markers
var edgeDotGeo = new THREE.BufferGeometry();
var edgeDotPos = [];
for (var i = 0; i < EDGE_N; i += 8) {
  edgeDotPos.push(edgePts[i].x, edgePts[i].y, edgePts[i].z);
}
edgeDotGeo.setAttribute('position', new THREE.Float32BufferAttribute(edgeDotPos, 3));
var edgeDots = new THREE.Points(edgeDotGeo, new THREE.PointsMaterial({
  color: 0xff8060, size: 0.03, transparent: true, opacity: 0.6
}));
scene.add(edgeDots);

var edgeGroup = [edgeCore, edgeGlow, edgeDots];

// ═══════════════════════════════════════════
//  WAVE Ψ = cos(t/2) along the edge
// ═══════════════════════════════════════════
var waveGeo = new THREE.BufferGeometry();
var wavePts = [];
var WAVE_N = 400;
for (var i = 0; i <= WAVE_N; i++) {
  var u = (i / WAVE_N) * Math.PI * 4;
  var p = mobiusPos(u, MW);
  // Displace outward by Ψ = cos(u/2)
  var psi = Math.cos(u / 2) * 0.2;
  // Get approximate outward normal at the edge
  var p2 = mobiusPos(u, MW * 0.9);
  var dx = p[0] - p2[0], dy = p[1] - p2[1], dz = p[2] - p2[2];
  var dl = Math.sqrt(dx*dx + dy*dy + dz*dz) || 1;
  wavePts.push(
    new THREE.Vector3(p[0] + psi * dx/dl, p[1] + psi * dy/dl, p[2] + psi * dz/dl)
  );
}

var waveLine = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(wavePts),
  new THREE.LineBasicMaterial({ color: 0xf0c040, transparent: true, opacity: 0.8, linewidth: 1 })
);
waveLine.visible = false;
scene.add(waveLine);

// Wave glow
var waveGlow = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(wavePts),
  new THREE.LineBasicMaterial({ color: 0xf0c040, transparent: true, opacity: 0.2, linewidth: 1 })
);
waveGlow.visible = false;
scene.add(waveGlow);

var waveGroup = [waveLine, waveGlow];

// ═══════════════════════════════════════════
//  ORBIT CONTROLS (manual implementation)
// ═══════════════════════════════════════════
var orbitTheta = 0.35;  // azimuthal
var orbitPhi = 0.3;     // polar (from top)
var orbitDist = 5;
var targetTheta = orbitTheta, targetPhi = orbitPhi, targetDist = orbitDist;
var dragging = false, prevX = 0, prevY = 0;
var autoRotate = true;

function updateCamera() {
  orbitTheta += (targetTheta - orbitTheta) * 0.08;
  orbitPhi += (targetPhi - orbitPhi) * 0.08;
  orbitDist += (targetDist - orbitDist) * 0.08;
  orbitPhi = Math.max(0.1, Math.min(Math.PI - 0.1, orbitPhi));
  orbitDist = Math.max(2.5, Math.min(10, orbitDist));
  camera.position.set(
    orbitDist * Math.sin(orbitPhi) * Math.cos(orbitTheta),
    orbitDist * Math.cos(orbitPhi),
    orbitDist * Math.sin(orbitPhi) * Math.sin(orbitTheta)
  );
  camera.lookAt(0, 0, 0);
}

document.addEventListener('mousedown', function(e) {
  if (e.target.closest('.controls, .annotation')) return;
  dragging = true; prevX = e.clientX; prevY = e.clientY;
});
document.addEventListener('mousemove', function(e) {
  if (!dragging) return;
  var dx = e.clientX - prevX, dy = e.clientY - prevY;
  targetTheta -= dx * 0.005;
  targetPhi -= dy * 0.005;
  prevX = e.clientX; prevY = e.clientY;
});
document.addEventListener('mouseup', function() { dragging = false; });
document.addEventListener('wheel', function(e) {
  targetDist += e.deltaY * 0.003;
});

// Touch support
document.addEventListener('touchstart', function(e) {
  if (e.target.closest('.controls, .annotation')) return;
  if (e.touches.length === 1) {
    dragging = true; prevX = e.touches[0].clientX; prevY = e.touches[0].clientY;
  }
}, { passive: true });
document.addEventListener('touchmove', function(e) {
  if (!dragging || e.touches.length !== 1) return;
  var dx = e.touches[0].clientX - prevX, dy = e.touches[0].clientY - prevY;
  targetTheta -= dx * 0.005;
  targetPhi -= dy * 0.005;
  prevX = e.touches[0].clientX; prevY = e.touches[0].clientY;
}, { passive: true });
document.addEventListener('touchend', function() { dragging = false; });

// ═══════════════════════════════════════════
//  LAYER TOGGLES
// ═══════════════════════════════════════════
var layers = { space: true, surface: true, edge: true, wave: false };

var annotations = {
  space: {
    label: "Space", name: "S\u00B3 Hypersphere",
    body: "Closed, simply connected, no boundary. The Poincar\u00E9 theorem guarantees S\u00B3 is unique among closed 3-manifolds. Contains everything. Holds everything.",
    math: "\u2202S\u00B3 = \u2205"
  },
  surface: {
    label: "Surface", name: "Mobius Strip",
    body: "Non-orientable. One boundary. A field traversing the surface returns to minus itself. The unique non-orientable surface with a single boundary component.",
    math: "\u03C8(y + L) = \u2212\u03C8(y)"
  },
  edge: {
    label: "Edge", name: "S\u00B9 Temporal Boundary",
    body: "The boundary of the Mobius surface. Phase advances along this edge. Time is not a container; it is the boundary of a surface. Period 4\u03C0. One lap returns negative.",
    math: "S\u00B9 = \u2202(Mobius)"
  },
  wave: {
    label: "Wave", name: "\u03A8 = cos(t/2)",
    body: "The standing wave on the edge. Cosine because t = 0 is a maximum. Anti-periodicity requires period 4\u03C0. Present epoch at t \u2248 5.22 rad. This is the wave everything samples.",
    math: "\u03A8 = cos(t/2)"
  }
};

function setAnnotation(key) {
  var a = annotations[key];
  document.getElementById('aLabel').textContent = a.label;
  document.getElementById('aName').innerHTML = a.name;
  document.getElementById('aBody').innerHTML = a.body;
  document.getElementById('aMath').textContent = a.math;
}

function applyLayers() {
  spaceGroup.forEach(function(m) { m.visible = layers.space; });
  surfaceGroup.forEach(function(m) { m.visible = layers.surface; });
  edgeGroup.forEach(function(m) { m.visible = layers.edge; });
  waveGroup.forEach(function(m) { m.visible = layers.wave; });
}

document.querySelectorAll('.ctrl-btn').forEach(function(btn) {
  btn.addEventListener('click', function() {
    var key = btn.dataset.layer;
    layers[key] = !layers[key];
    btn.classList.toggle('active', layers[key]);
    applyLayers();
    if (layers[key]) setAnnotation(key);
  });
});

applyLayers();

// ── Rotate toggle ──
document.getElementById('btnRotate').addEventListener('click', function() {
  autoRotate = !autoRotate;
  this.classList.toggle('active', autoRotate);
});

// ═══════════════════════════════════════════
//  ANIMATION LOOP
// ═══════════════════════════════════════════
var clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  var t = clock.getElapsedTime();

  // Auto-rotate
  if (autoRotate) {
    targetTheta += 0.002;
  }
  updateCamera();

  // Gentle surface breathing
  if (layers.surface) {
    mobiusMat.opacity = 0.8 + 0.05 * Math.sin(t * 0.5);
  }

  // Edge pulse
  if (layers.edge) {
    edgeCore.material.opacity = 0.85 + 0.1 * Math.sin(t * 1.5);
    edgeGlow.material.opacity = 0.25 + 0.1 * Math.sin(t * 1.5 + 0.5);
  }

  // Sphere subtle breathe
  if (layers.space) {
    sphereShell.material.opacity = 0.05 + 0.02 * Math.sin(t * 0.3);
  }

  // Wave animation: phase shift
  if (layers.wave) {
    var wPos = waveLine.geometry.attributes.position.array;
    for (var i = 0; i <= WAVE_N; i++) {
      var u = (i / WAVE_N) * Math.PI * 4;
      var p = mobiusPos(u, MW);
      var psi = Math.cos(u / 2 - t * 0.4) * 0.2;
      var p2 = mobiusPos(u, MW * 0.9);
      var dx = p[0]-p2[0], dy = p[1]-p2[1], dz = p[2]-p2[2];
      var dl = Math.sqrt(dx*dx+dy*dy+dz*dz) || 1;
      wPos[i*3]   = p[0] + psi * dx/dl;
      wPos[i*3+1] = p[1] + psi * dy/dl;
      wPos[i*3+2] = p[2] + psi * dz/dl;
    }
    waveLine.geometry.attributes.position.needsUpdate = true;

    // Copy to glow
    var gPos = waveGlow.geometry.attributes.position.array;
    for (var i = 0; i < wPos.length; i++) gPos[i] = wPos[i];
    waveGlow.geometry.attributes.position.needsUpdate = true;

    waveLine.material.opacity = 0.7 + 0.15 * Math.sin(t);
  }

  renderer.render(scene, camera);
}

animate();

// ── Resize ──
window.addEventListener('resize', function() {
  W = window.innerWidth; H = window.innerHeight;
  camera.aspect = W / H;
  camera.updateProjectionMatrix();
  renderer.setSize(W, H);
});

// ── Annotation cycling on auto-rotate ──
var annotKeys = ['space', 'surface', 'edge'];
var annotIdx = 0;
setInterval(function() {
  if (!autoRotate) return;
  annotIdx = (annotIdx + 1) % annotKeys.length;
  setAnnotation(annotKeys[annotIdx]);
}, 6000);

})();
</script>
</body>
</html>
